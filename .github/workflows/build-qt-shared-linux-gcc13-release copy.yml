name: Build Qt 6.x.x -Release -shared for Linux (GCC13)

on:
  workflow_dispatch:
    inputs:
      qt_majmin:
        description: 'Qt 主版本号与次版本号(>=6.7.0)'
        required: true
        default: '6.9'
      qt_patch:
        description: 'Qt 补丁版本号(例如 0)'
        required: false
        default: '0'

jobs:
  build-qt:
    name: Build Qt ${{ inputs.qt_majmin }}.${{ inputs.qt_patch }} – ${{ matrix.config }} for Linux
    runs-on: ubuntu-latest
    permissions:
      contents: write

    strategy:
      matrix:
        config: [RelWithDebInfo]
    env:
      QT_MAJMIN: ${{ inputs.qt_majmin }}
      QT_VERSION: ${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}
      TAG: v${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}-shared
      GITHUB_REPOSITORY: ${{ github.repository }}
      GH_TOKEN: ${{ github.token }}
      QT_SOURCE_URL: https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/${{ inputs.qt_majmin }}/${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}/single/qt-everywhere-src-${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}.tar.xz

    steps:
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 5120
          swap-size-mb: 2048
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'
      
      - name: Redirect Runner logs / temp / cache to build volume
        shell: bash
        run: |
          set -euo pipefail

          BUILD_VOL=$(dirname "$GITHUB_WORKSPACE")
          sudo mkdir -p "$BUILD_VOL/.runner"

          DIAG_NEW="$BUILD_VOL/.runner/_diag"
          sudo mkdir -p "$DIAG_NEW"

          # 1) 如果已有日志，先复制到构建卷（保留历史）
          if [[ -d /home/runner/actions-runner/cached/_diag ]]; then
            echo "Copying existing diag logs to $DIAG_NEW ..."
            sudo rsync -aHAX --delete /home/runner/actions-runner/cached/_diag/ "$DIAG_NEW/" || true
            sudo chown -R runner:runner "$DIAG_NEW" || true

            # 2) 在原路径截断日志文件以释放空间（不会删除文件路径）
            echo "Truncating original log files in-place to free space ..."
            sudo find /home/runner/actions-runner/cached/_diag -type f -print0 \
              | while IFS= read -r -d '' file; do
                  # 仅截断常见日志文件，避免对非日志（例如 socket/特殊文件）误操作
                  # 如果你只想截断 *.log, 可替换 find 条件为 -name '*.log'
                  echo "Truncating: $file"
                  sudo truncate -s 0 "$file" || true
                done
          else
            echo "No existing /home/runner/actions-runner/cached/_diag found — creating target dir only."
          fi

          # 3) 尝试清理 'deleted but open' 的句柄（如果存在）
          #    先列出有问题的 PID（如果没有输出则跳过）
          DELETED_PIDS=$(sudo lsof +L1 -t || true)
          if [[ -n "${DELETED_PIDS// /}" ]]; then
            echo "Found processes holding deleted files: $DELETED_PIDS"
            echo "Attempting to truncate their open fds via /proc/.../fd/..."
            for pid in $DELETED_PIDS; do
              # iterate file descriptors
              for fdpath in /proc/"$pid"/fd/*; do
                [ -e "$fdpath" ] || continue
                target=$(readlink "$fdpath" 2>/dev/null || true)
                if [[ "$target" == *"(deleted)"* ]]; then
                  echo "Truncating $fdpath (pid $pid) -> target: $target"
                  sudo truncate -s 0 "$fdpath" || true
                fi
              done
            done
          else
            echo "No deleted-but-open files found."
          fi
          echo "Detecting processes that hold deleted files..."
          # 获取持有 deleted-but-open 文件的 PID 列表（唯一）
          PIDS=$(sudo lsof +L1 -t || true)
          if [[ -z "$PIDS" ]]; then
            echo "No processes holding deleted files found."
            exit 0
          fi

          echo "PIDs found: $PIDS"
          for pid in $PIDS; do
            if ! sudo kill -0 "$pid" 2>/dev/null; then
              echo "PID $pid is not running any more - skipping"
              continue
            fi

            echo "=== PID $pid info ==="
            sudo ps -p "$pid" -o pid,ppid,user,cmd --no-headers || true
            echo "Open fds (showing deleted ones):"
            sudo ls -l /proc/"$pid"/fd || true

            # 针对每个 fd，如果指向 "(deleted)"，尝试 truncate（忽略错误）
            for fdpath in /proc/"$pid"/fd/*; do
              [ -e "$fdpath" ] || continue
              target=$(readlink "$fdpath" 2>/dev/null || true)
              if [[ "$target" == *"(deleted)"* ]]; then
                echo "Truncating fd $fdpath -> $target"
                # 尝试 truncate，若失败再尝试 shell 重定向（两种方式取其一）
                sudo truncate -s 0 "$fdpath" 2>/dev/null || sudo bash -c '> "$fdpath"' 2>/dev/null || echo "truncate failed (ignored)"
              fi
            done

            echo "Done with PID $pid"
            echo
          done

          echo "Check disk usage and remaining deleted-but-open files:"
          df -h || true
          sudo lsof +L1 || true

          # 4) 临时目录 (RUNNER_TEMP/TMPDIR/TEMP/TMP)
          NEW_TEMP="$BUILD_VOL/.runner/tmp"
          sudo mkdir -p "$NEW_TEMP"
          sudo chmod 1777 "$NEW_TEMP"
          echo "RUNNER_TEMP=$NEW_TEMP" >> "$GITHUB_ENV"
          echo "TMPDIR=$NEW_TEMP"      >> "$GITHUB_ENV"
          echo "TEMP=$NEW_TEMP"        >> "$GITHUB_ENV"
          echo "TMP=$NEW_TEMP"         >> "$GITHUB_ENV"

          # 5) 工具缓存
          sudo mkdir -p "$BUILD_VOL/.runner/toolcache"
          sudo chown -R runner:runner "$BUILD_VOL/.runner/toolcache" || true
          sudo ln -sfn "$BUILD_VOL/.runner/toolcache" /opt/hostedtoolcache || true
          echo "AGENT_TOOLSDIRECTORY=$BUILD_VOL/.runner/toolcache" >> "$GITHUB_ENV"

          # 6) Docker 数据根目录（如可用）
          #    停 docker 仅在可行时执行（某些 hosted 环境可能不允许）
          if command -v systemctl >/dev/null 2>&1; then
            echo "Reconfiguring docker data-root..."
            sudo systemctl stop docker || true
            sudo mkdir -p "$BUILD_VOL/.runner/docker"
            echo '{"data-root":"'"$BUILD_VOL/.runner/docker"'"}' | sudo tee /etc/docker/daemon.json > /dev/null
            sudo systemctl start docker || true
          else
            echo "systemctl not available; skipping docker data-root reconfigure."
          fi

          # 7) 最后检查磁盘使用与残留被删除占用
          echo "Disk usage after actions:"
          df -h || true
          echo "List deleted-but-open files (if any):"
          sudo lsof +L1 || true

          echo "Done. Note: if lsof still shows deleted-but-open entries, consider a short maintenance window to restart the runner service to fully free space."

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          architecture: 'x64'

      - name: Cache Qt source
        id: cache-qt-source
        uses: actions/cache@v3
        with:
          key: qt-src-${{ env.QT_VERSION }}-Unix
          path: ${{ runner.temp }}/qt6_src

      - name: 安装构建工具（Linux）
        id: install_build_tools
        run: |
          sudo apt-get update
          # 安装指定版本的 GCC/G++ 13 以及其他构建工具
          sudo apt-get -y install gcc-13 g++-13 cmake ninja-build \
           libssl-dev gperf xz-utils \
           libgl1-mesa-dev libglu1-mesa-dev libegl1-mesa-dev \
           libx11-dev libxext-dev libxcb1-dev \
           protobuf-compiler libprotobuf-dev \
           llvm-16-dev libclang-16-dev clang-16 lld-16 libclang-16-dev 
          echo "🔍 工具位置："
          for tool in gcc-13 g++-13 cmake ninja openssl protoc; do which $tool || echo "$tool 未找到"; done
          # 设置默认 gcc / g++ 指向版本 13
          sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 600
          sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 600
          # 验证
          gcc --version
          g++ --version
          echo "🔍 LLVM工具验证："
          ls -l /usr/lib/llvm-16/lib/libclangBasic.a  # 确认文件存在
          clang-16 --version

      - name: Download & extract Qt
        if: steps.cache-qt-source.outputs.cache-hit != 'true'
        run: |
          ARCHIVE="$RUNNER_TEMP/qt6.tar.xz"
          TARGET_DIR="$RUNNER_TEMP/qt6_src"
          echo "📦 Downloading Qt source archive..."
          curl -L -o "$ARCHIVE" "$QT_SOURCE_URL"
          echo "📂 Extracting .tar.xz via tar..."
          rm -rf "$TARGET_DIR"
          mkdir -p "$TARGET_DIR"
          # -x: extract; -J: .xz; -f: file; -C: target dir
          tar -xJf "$ARCHIVE" -C "$TARGET_DIR"
          echo "✅ Extraction complete: $TARGET_DIR"
          df -h

      - name: Configure & build & install ${{ matrix.config }}
        env:
          CONFIG: ${{ matrix.config }}
        run: |
          SRC_QT="$RUNNER_TEMP/qt6_src/qt-everywhere-src-$QT_VERSION"
          BUILD_DIR="$RUNNER_TEMP/build-${CONFIG}"
          INSTALL_DIR="$RUNNER_TEMP/qt-$QT_VERSION/$CONFIG"
          ARTIFACTS_DIR="$RUNNER_TEMP/artifacts"

          rm -rf "$BUILD_DIR"
          mkdir -p "$BUILD_DIR" && cd "$BUILD_DIR"
          mkdir -p "$INSTALL_DIR" "$ARTIFACTS_DIR"

          if [[ "$CONFIG" == "Debug" ]]; then
            MODE="-debug"
          elif [[ "$CONFIG" == "Release" ]]; then
            MODE="-release"
          else
            MODE="-release -force-debug-info"
          fi

          "$SRC_QT/configure" -shared $MODE -reduce-exports \
            -prefix "$INSTALL_DIR" -no-pch \
            -nomake examples -nomake tests -skip qtwebengine -opensource \
            -confirm-license -qt-libpng -qt-libjpeg -qt-zlib -qt-pcre -qt-freetype \
            -no-sql-psql -- -Wno-dev

          cmake --build . --parallel 2
          cmake --install .

      - name: Package ${{ matrix.config }} as tar.gz
        run: |
          ASSET="qt-${QT_VERSION}-shared-linux-gcc13_x64-${{ matrix.config }}.tar.gz"
          echo "📦 正在打包 ${{ matrix.config }} -> $ASSET..."
          cd "$RUNNER_TEMP/qt-${QT_VERSION}"
          tar -czf "$RUNNER_TEMP/artifacts/$ASSET" -C . "${{ matrix.config }}"
      
      - name: Create Tag if not exists
        if: github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          REPO:      ${{ github.repository }}
          TAG:       v${{ env.QT_VERSION }}-shared
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Local tag $TAG already exists, skip."
          elif git ls-remote --tags origin "$TAG" | grep -q "$TAG"; then
            echo "Remote tag $TAG already exists, skip."
          else
            git tag "$TAG"
            git push "https://x-access-token:$PAT_TOKEN@github.com/$REPO" "$TAG"
            echo "Tag $TAG created and pushed."
          fi

      - name: Ensure Release exists or create
        id: ensure_release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="v${{ env.QT_VERSION }}-shared"
          if gh release view "$TAG" > /dev/null 2>&1; then
            echo "found=existing" >> $GITHUB_OUTPUT
          else
            echo "found=new" >> $GITHUB_OUTPUT
            gh release create "$TAG" \
              --title "Qt $TAG Auto Builds" \
              --notes "Automated build of Qt $TAG" \
              --draft=false \
              --prerelease=false
          fi

      - name: Upload build artifacts
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="v${{ env.QT_VERSION }}-shared"
          ASSET="qt-${QT_VERSION}-shared-linux-gcc13_x64-${{ matrix.config }}.tar.gz"
          FILE="$RUNNER_TEMP/artifacts/$ASSET"
          if [ -f "$FILE" ]; then
            gh release upload "$TAG" "$FILE" --clobber
          else
            echo "文件未找到，跳过上传：$FILE"
          fi
