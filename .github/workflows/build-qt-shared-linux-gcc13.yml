name: Build Qt 6.x.x -shared for Linux (GCC13)

on:
  workflow_dispatch:
    inputs:
      qt_majmin:
        description: 'Qt ä¸»ç‰ˆæœ¬å·ä¸æ¬¡ç‰ˆæœ¬å·(>=6.7.0)'
        required: true
        default: '6.9'
      qt_patch:
        description: 'Qt è¡¥ä¸ç‰ˆæœ¬å·(ä¾‹å¦‚ 0)'
        required: false
        default: '0'

jobs:
  build-qt:
    name: Build Qt ${{ inputs.qt_majmin }}.${{ inputs.qt_patch }} â€“ ${{ matrix.config }} for Linux
    runs-on: ubuntu-latest
    permissions:
      contents: write

    strategy:
      matrix:
        config: [Debug, Release, RelWithDebInfo]
    env:
      QT_MAJMIN: ${{ inputs.qt_majmin }}
      QT_VERSION: ${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}
      TAG: v${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}-shared
      GITHUB_REPOSITORY: ${{ github.repository }}
      GH_TOKEN: ${{ github.token }}
      QT_SOURCE_URL: https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/${{ inputs.qt_majmin }}/${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}/single/qt-everywhere-src-${{ inputs.qt_majmin }}.${{ inputs.qt_patch }}.tar.xz

    steps:
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 5120
          swap-size-mb: 1024
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'

      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Redirect Runner logs / temp / cache to build volume
        shell: bash
        run: |
          set -euo pipefail

          sudo mkdir -p "$GITHUB_WORKSPACE/.runner"
          sudo chown -R runner:runner "$GITHUB_WORKSPACE/.runner"

          # 1) ä¸´æ—¶ç›®å½• (RUNNER_TEMP/TMPDIR/TEMP/TMP)
          NEW_TEMP="$GITHUB_WORKSPACE/.runner/tmp"
          sudo mkdir -p "$NEW_TEMP"
          sudo chmod 1777 "$NEW_TEMP"
          echo "RUNNER_TEMP=$NEW_TEMP" >> "$GITHUB_ENV"
          echo "TMPDIR=$NEW_TEMP"      >> "$GITHUB_ENV"
          echo "TEMP=$NEW_TEMP"        >> "$GITHUB_ENV"
          echo "TMP=$NEW_TEMP"         >> "$GITHUB_ENV"

          # 2) æœ€åæ£€æŸ¥ç£ç›˜ä½¿ç”¨ä¸æ®‹ç•™è¢«åˆ é™¤å ç”¨
          echo "Disk usage after actions:"
          df -h || true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          architecture: 'x64'

      - name: Cache Qt source
        id: cache-qt-source
        uses: actions/cache@v3
        with:
          key: qt-src-${{ env.QT_VERSION }}-Unix
          path: ${{ github.workspace }}/.runner/tmp/qt6_src

      - name: å®‰è£…æ„å»ºå·¥å…·ï¼ˆLinuxï¼‰
        id: install_build_tools
        run: |
          source scripts/functions.sh
          sudo apt-get update
          # å®‰è£…æŒ‡å®šç‰ˆæœ¬çš„ GCC/G++ 13 ä»¥åŠå…¶ä»–æ„å»ºå·¥å…·
          sudo apt-get -y install gcc-13 g++-13 cmake ninja-build \
           libssl-dev gperf xz-utils \
           libgl1-mesa-dev libglu1-mesa-dev libegl1-mesa-dev \
           libx11-dev libxext-dev libxcb1-dev \
           protobuf-compiler libprotobuf-dev
          
          install_ver_pkgs llvm-dev libclang-dev clang lld
          echo "ğŸ” å·¥å…·ä½ç½®ï¼š"
          for tool in gcc-13 g++-13 cmake ninja openssl protoc; do which $tool || echo "$tool æœªæ‰¾åˆ°"; done
          # è®¾ç½®é»˜è®¤ gcc / g++ æŒ‡å‘ç‰ˆæœ¬ 13
          sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 600
          sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 600
          # éªŒè¯
          gcc --version
          g++ --version
          echo "ğŸ” LLVMå·¥å…·éªŒè¯ï¼š"
          ls -l /usr/lib/llvm*/lib/libclangBasic.a  # ç¡®è®¤æ–‡ä»¶å­˜åœ¨
          clang --version

      - name: Download & extract Qt
        if: steps.cache-qt-source.outputs.cache-hit != 'true'
        run: |
          export NEW_RUNNER_TEMP="$GITHUB_WORKSPACE/.runner/tmp"
          ARCHIVE="$NEW_RUNNER_TEMP/qt6.tar.xz"
          TARGET_DIR="$NEW_RUNNER_TEMP/qt6_src"
          echo "ğŸ“¦ Downloading Qt source archive..."
          curl -L -o "$ARCHIVE" "$QT_SOURCE_URL"
          echo "ğŸ“‚ Extracting .tar.xz via tar..."
          rm -rf "$TARGET_DIR"
          mkdir -p "$TARGET_DIR"
          # -x: extract; -J: .xz; -f: file; -C: target dir
          tar -xJf "$ARCHIVE" -C "$TARGET_DIR"
          echo "âœ… Extraction complete: $TARGET_DIR"
          echo "Disk usage after actions:"
          df -h || true

      - name: Configure & build & install ${{ matrix.config }}
        env:
          CONFIG: ${{ matrix.config }}
        run: |
          export NEW_RUNNER_TEMP="$GITHUB_WORKSPACE/.runner/tmp"
          SRC_QT="$NEW_RUNNER_TEMP/qt6_src/qt-everywhere-src-$QT_VERSION"
          BUILD_DIR="$NEW_RUNNER_TEMP/build-${CONFIG}"
          INSTALL_DIR="$NEW_RUNNER_TEMP/qt-$QT_VERSION/$CONFIG"
          ARTIFACTS_DIR="$NEW_RUNNER_TEMP/artifacts"

          rm -rf "$BUILD_DIR"
          mkdir -p "$BUILD_DIR" && cd "$BUILD_DIR"
          mkdir -p "$INSTALL_DIR" "$ARTIFACTS_DIR"

          if [[ "$CONFIG" == "Debug" ]]; then
            MODE="-debug"
          elif [[ "$CONFIG" == "Release" ]]; then
            MODE="-release"
          else
            MODE="-release -force-debug-info"
          fi

          "$SRC_QT/configure" -shared $MODE -reduce-exports \
            -prefix "$INSTALL_DIR" -no-pch \
            -nomake examples -nomake tests -skip qtwebengine -opensource \
            -confirm-license -qt-libpng -qt-libjpeg -qt-zlib -qt-pcre -qt-freetype \
            -no-sql-psql -- -Wno-dev
          echo "Disk usage after actions:"
          df -h || true

          cmake --build . --parallel 2
          echo "Disk usage after actions:"
          df -h || true
          cmake --install .
          echo "Disk usage after actions:"
          df -h || true

      - name: Package ${{ matrix.config }} as tar.gz
        run: |
          set -euo pipefail
          export NEW_RUNNER_TEMP="$GITHUB_WORKSPACE/.runner/tmp"
          ARTIFACTS_DIR="$NEW_RUNNER_TEMP/artifacts"

          BASE="qt-${QT_VERSION}-shared-linux-gcc13_x64-${{ matrix.config }}"
          SINGLE="$ARTIFACTS_DIR/$BASE.tar.gz"
          LIMIT=$((1950 * 1024 * 1024))

          SRC_DIR="$NEW_RUNNER_TEMP/qt-${QT_VERSION}"

          echo "ğŸ“¦ Trying to create single archive: $SINGLE"
          tar -C "$SRC_DIR" -czf "$SINGLE" "${{ matrix.config }}"

          SIZE=$(stat -c%s "$SINGLE")

          echo "ğŸ“ Archive size: $((SIZE/1024/1024)) MiB (limit is $((LIMIT/1024/1024)) MiB)"

          if (( SIZE > LIMIT )); then
            echo "âš ï¸  Size exceeds limit, regenerating as split volumesâ€¦"
            rm -f "$SINGLE"

            # ä½¿ç”¨ç®¡é“å‹ç¼©å¹¶åˆ†å·ï¼Œæ¯å· 1950m
            tar -C "$SRC_DIR" -czf - "${{ matrix.config }}" \
              | split -b1950m - "$ARTIFACTS_DIR/$BASE.tar.gz.part-"

            echo "âœ… Created split volumes in $ARTIFACTS_DIR:"
            ls -1 "$ARTIFACTS_DIR/$BASE.tar.gz.part-"*
          else
            echo "âœ… Created single archive: $SINGLE"
          fi

      - name: Create Tag if not exists
        if: github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main'
        shell: bash
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          REPO:      ${{ github.repository }}
          TAG:       v${{ env.QT_VERSION }}-shared
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Local tag $TAG already exists, skip."
          elif git ls-remote --tags origin "$TAG" | grep -q "$TAG"; then
            echo "Remote tag $TAG already exists, skip."
          else
            git tag "$TAG"
            git push "https://x-access-token:$PAT_TOKEN@github.com/$REPO" "$TAG"
            echo "Tag $TAG created and pushed."
          fi

      - name: Ensure Release exists or create
        id: ensure_release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="v${{ env.QT_VERSION }}-shared"
          if gh release view "$TAG" > /dev/null 2>&1; then
            echo "found=existing" >> $GITHUB_OUTPUT
          else
            echo "found=new" >> $GITHUB_OUTPUT
            gh release create "$TAG" \
              --title "Qt $TAG Auto Builds" \
              --notes "Automated build of Qt $TAG" \
              --draft=false \
              --prerelease=false
          fi

      - name: Upload build artifacts
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          export NEW_RUNNER_TEMP="$GITHUB_WORKSPACE/.runner/tmp"
          BASE="qt-${QT_VERSION}-shared-linux-gcc13_x64-${{ matrix.config }}"
          TAG="v${{ env.QT_VERSION }}-shared"
          ART_DIR="$NEW_RUNNER_TEMP/artifacts"
          echo "ğŸ” Looking for artifacts in $ART_DIR matching $BASE*"
          found=false
          # æ³¨æ„ï¼šå¦‚æœæ²¡æœ‰åŒ¹é…é¡¹ï¼Œbash ä¼šæŠŠ glob æœ¬èº«å½“åšå­—é¢å­—ç¬¦ä¸²ï¼›
          # æ‰€ä»¥è¿™é‡Œå…ˆæµ‹è¯•ä¸€ä¸‹æ–‡ä»¶æ˜¯å¦çœŸçš„å­˜åœ¨ã€‚
          for file in "$ART_DIR"/"$BASE"*.tar.gz*; do
            if [ -e "$file" ]; then
              echo "ğŸ“¤ Uploading $(basename "$file") to release $TAG"
              gh release upload "$TAG" "$file" --clobber
              found=true
            fi
          done

          if ! $found; then
            echo "âŒ No artifacts found to upload for $BASE"
            exit 1
          fi

          echo "âœ… All artifacts uploaded."
